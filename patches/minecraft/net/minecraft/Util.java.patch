--- a/net/minecraft/Util.java
+++ b/net/minecraft/Util.java
@@ -4,6 +_,7 @@
 import com.google.common.collect.Iterators;
 import com.google.common.collect.Lists;
 import com.google.common.util.concurrent.MoreExecutors;
+import com.mohistmc.paper.util.ServerWorkerThread;
 import com.mojang.datafixers.DSL;
 import com.mojang.datafixers.DataFixUtils;
 import com.mojang.datafixers.types.Type;
@@ -82,7 +_,23 @@
    private static final String f_183936_ = "max.bg.threads";
    private static final AtomicInteger f_137442_ = new AtomicInteger(1);
    private static final ExecutorService f_137444_ = m_137477_("Main");
-   private static final ExecutorService f_137445_ = m_137586_();
+    // Paper start - don't submit BLOCKING PROFILE LOOKUPS to the world gen thread
+    public static final ExecutorService PROFILE_EXECUTOR = Executors.newFixedThreadPool(2, new java.util.concurrent.ThreadFactory() {
+
+        private final AtomicInteger count = new AtomicInteger();
+
+        @Override
+        public Thread newThread(Runnable run) {
+            Thread ret = new Thread(run);
+            ret.setName("Profile Lookup Executor #" + this.count.getAndIncrement());
+            ret.setUncaughtExceptionHandler((Thread thread, Throwable throwable) -> {
+                f_137446_.error("Uncaught exception in thread " + thread.getName(), throwable);
+            });
+            return ret;
+        }
+    });
+    // Paper end - don't submit BLOCKING PROFILE LOOKUPS to the world gen thread
+    private static final ExecutorService f_137445_ = m_137586_();
    private static final DateTimeFormatter f_241646_ = DateTimeFormatter.ofPattern("yyyy-MM-dd_HH.mm.ss", Locale.ROOT);
    public static TimeSource.NanoTimeSource f_137440_ = System::nanoTime;
    public static final Ticker f_211544_ = new Ticker() {
@@ -153,6 +_,30 @@
       return executorservice;
    }
 
+    private static ExecutorService makeExecutorPaper(String p_137478_, int priorityModifier) {
+        // Paper start - Perf: use simpler thread pool that allows 1 thread and reduce worldgen thread worker count for low core count CPUs
+        int cpus = Runtime.getRuntime().availableProcessors() / 2;
+        int i;
+        if (cpus <= 4) {
+            i = cpus <= 2 ? 1 : 2;
+        } else if (cpus <= 8) {
+            // [5, 8]
+            i = Math.max(3, cpus - 2);
+        } else {
+            i = cpus * 2 / 3;
+        }
+        i = Math.min(8, i);
+        i = Integer.getInteger("Paper.WorkerThreadCount", i);
+        ExecutorService executorService;
+        if (i <= 0) {
+            executorService = MoreExecutors.newDirectExecutorService();
+        } else {
+            executorService = new java.util.concurrent.ThreadPoolExecutor(i, i,0L, TimeUnit.MILLISECONDS, new java.util.concurrent.LinkedBlockingQueue<>(), target -> new ServerWorkerThread(target, p_137478_, priorityModifier));
+        }
+
+        return executorService;
+    }
+
    private static int m_183993_() {
       String s = System.getProperty("max.bg.threads");
       if (s != null) {
@@ -171,6 +_,11 @@
       return 255;
    }
 
+   // We add these inner classes to compensate for Mojang's missing inner classes and shift the anonymous class index.
+   // This allows us to obfuscate subsequent anonymous inner classes correctly.
+   @SuppressWarnings("unused") private static java.util.function.LongSupplier INNER_CLASS_SHIFT1 = () -> 0;
+   @SuppressWarnings("unused") private static java.util.function.LongSupplier INNER_CLASS_SHIFT2 = () -> 0;
+
    public static ExecutorService m_183991_() {
       return f_137444_;
    }
@@ -213,7 +_,7 @@
       throw p_137560_ instanceof RuntimeException ? (RuntimeException)p_137560_ : new RuntimeException(p_137560_);
    }
 
-   private static void m_137495_(Thread p_137496_, Throwable p_137497_) {
+   public static void m_137495_(Thread p_137496_, Throwable p_137497_) {
       m_137570_(p_137497_);
       if (p_137497_ instanceof CompletionException) {
          p_137497_ = p_137497_.getCause();
@@ -239,7 +_,7 @@
       try {
          type = DataFixers.m_14512_().getSchema(DataFixUtils.makeKey(SharedConstants.m_183709_().m_183476_().m_193006_())).getChoiceType(p_137552_, p_137553_);
       } catch (IllegalArgumentException illegalargumentexception) {
-         f_137446_.error("No data fixer registered for {}", (Object)p_137553_);
+         f_137446_.debug("No data fixer registered for {}", (Object)p_137553_);
          if (SharedConstants.f_136183_) {
             throw illegalargumentexception;
          }
@@ -428,7 +_,7 @@
    }
 
    public static void m_143785_(String p_143786_) {
-      f_137446_.error(p_143786_);
+      // LOGGER.error(p_143786_);
       if (SharedConstants.f_136183_) {
          m_183984_(p_143786_);
       }
@@ -436,7 +_,7 @@
    }
 
    public static void m_200890_(String p_200891_, Throwable p_200892_) {
-      f_137446_.error(p_200891_, p_200892_);
+      // LOGGER.error(p_200891_, p_200892_);
       if (SharedConstants.f_136183_) {
          m_183984_(p_200891_);
       }
@@ -445,7 +_,7 @@
 
    public static <T extends Throwable> T m_137570_(T p_137571_) {
       if (SharedConstants.f_136183_) {
-         f_137446_.error("Trying to throw a fatal exception, pausing in IDE", p_137571_);
+         // LOGGER.error("Trying to throw a fatal exception, pausing in IDE", p_137571_);
          m_183984_(p_137571_.getMessage());
       }
 
@@ -458,7 +_,7 @@
 
    private static void m_183984_(String p_183985_) {
       Instant instant = Instant.now();
-      f_137446_.warn("Did you remember to set a breakpoint here?");
+      // LOGGER.warn("Did you remember to set a breakpoint here?");
       boolean flag = Duration.between(instant, Instant.now()).toMillis() > 500L;
       if (!flag) {
          f_183937_.accept(p_183985_);
@@ -695,30 +_,30 @@
 
    public static <T, R> Function<T, R> m_143827_(final Function<T, R> p_143828_) {
       return new Function<T, R>() {
-         private final Map<T, R> f_211548_ = new ConcurrentHashMap<>();
+         private final Map<T, R> cache = new ConcurrentHashMap<>();
 
          public R apply(T p_214691_) {
-            return this.f_211548_.computeIfAbsent(p_214691_, p_143828_);
+            return this.cache.computeIfAbsent(p_214691_, p_143828_);
          }
 
          public String toString() {
-            return "memoize/1[function=" + p_143828_ + ", size=" + this.f_211548_.size() + "]";
+            return "memoize/1[function=" + p_143828_ + ", size=" + this.cache.size() + "]";
          }
       };
    }
 
    public static <T, U, R> BiFunction<T, U, R> m_143821_(final BiFunction<T, U, R> p_143822_) {
       return new BiFunction<T, U, R>() {
-         private final Map<Pair<T, U>, R> f_214693_ = new ConcurrentHashMap<>();
+         private final Map<Pair<T, U>, R> f_211548_ = new ConcurrentHashMap<>();
 
          public R apply(T p_214700_, U p_214701_) {
-            return this.f_214693_.computeIfAbsent(Pair.of(p_214700_, p_214701_), (p_214698_) -> {
+            return this.f_211548_.computeIfAbsent(Pair.of(p_214700_, p_214701_), (p_214698_) -> {
                return p_143822_.apply(p_214698_.getFirst(), p_214698_.getSecond());
             });
          }
 
          public String toString() {
-            return "memoize/2[function=" + p_143822_ + ", size=" + this.f_214693_.size() + "]";
+            return "memoize/2[function=" + p_143822_ + ", size=" + this.f_211548_.size() + "]";
          }
       };
    }
